/**
 * GitHub Client
 * Handles GitHub API operations using Octokit
 */

import { Octokit } from '@octokit/rest';
import { createLogger, Logger } from '@chronosops/shared';
import { GitConfig, CreateRepoOptions, DEFAULT_GIT_CONFIG } from '../types.js';

export interface GitHubClientOptions {
  config?: Partial<GitConfig>;
  logger?: Logger;
}

export interface GitHubRepoInfo {
  id: number;
  name: string;
  fullName: string;
  description: string | null;
  private: boolean;
  htmlUrl: string;
  cloneUrl: string;
  sshUrl: string;
  defaultBranch: string;
  createdAt: Date;
  updatedAt: Date;
  pushedAt: Date | null;
}

export interface CreateGitHubRepoResult {
  success: boolean;
  repo?: GitHubRepoInfo;
  error?: string;
}

export interface DeleteGitHubRepoResult {
  success: boolean;
  error?: string;
}

export class GitHubClient {
  private readonly config: GitConfig;
  private readonly logger: Logger;
  private octokit: Octokit | null = null;

  constructor(options: GitHubClientOptions = {}) {
    this.config = { ...DEFAULT_GIT_CONFIG, ...options.config };
    this.logger = options.logger ?? createLogger('GitHubClient');
  }

  /**
   * Check if GitHub is configured
   */
  isConfigured(): boolean {
    return Boolean(this.config.githubToken && this.config.githubOrg);
  }

  /**
   * Get Octokit instance (lazy initialization)
   */
  private getOctokit(): Octokit {
    if (!this.octokit) {
      if (!this.config.githubToken) {
        throw new Error('GitHub token not configured');
      }
      this.octokit = new Octokit({
        auth: this.config.githubToken,
      });
    }
    return this.octokit;
  }

  /**
   * Get the organization/user for repo operations
   */
  private getOwner(): string {
    if (!this.config.githubOrg) {
      throw new Error('GitHub organization/user not configured');
    }
    return this.config.githubOrg;
  }

  /**
   * Build repository name from service name
   */
  buildRepoName(serviceName: string): string {
    if (this.config.repoNamingPattern === 'chronosops-{serviceName}') {
      return `chronosops-${serviceName}`;
    } else if (this.config.customRepoPrefix) {
      return `${this.config.customRepoPrefix}${serviceName}`;
    }
    return serviceName;
  }

  /**
   * Check if a repository exists
   */
  async repoExists(repoName: string): Promise<boolean> {
    try {
      const octokit = this.getOctokit();
      await octokit.repos.get({
        owner: this.getOwner(),
        repo: repoName,
      });
      return true;
    } catch (error: unknown) {
      const err = error as { status?: number };
      if (err.status === 404) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Create a new repository
   */
  async createRepo(options: CreateRepoOptions): Promise<CreateGitHubRepoResult> {
    try {
      const octokit = this.getOctokit();
      const owner = this.getOwner();
      const repoName = this.buildRepoName(options.serviceName);

      this.logger.info(
        { owner, repoName, developmentCycleId: options.developmentCycleId },
        'Creating GitHub repository'
      );

      // Check if repo already exists
      const exists = await this.repoExists(repoName);
      if (exists) {
        this.logger.info({ owner, repoName }, 'Repository already exists');
        const repo = await this.getRepo(repoName);
        return { success: true, repo };
      }

      // Create the repository
      const response = await octokit.repos.createInOrg({
        org: owner,
        name: repoName,
        description: options.description ?? `Generated by ChronosOps for ${options.serviceName}`,
        private: options.isPrivate ?? true,
        auto_init: options.initializeWithReadme ?? false,
        has_issues: false,
        has_wiki: false,
        has_projects: false,
      });

      const repo = this.mapToRepoInfo(response.data);
      this.logger.info({ owner, repoName, repoId: repo.id }, 'GitHub repository created');

      return { success: true, repo };
    } catch (error: unknown) {
      const err = error as { message?: string; status?: number };
      const errorMessage = err.message ?? 'Unknown error creating repository';
      this.logger.error({ error: errorMessage }, 'Failed to create GitHub repository');
      
      // Check if it's a permission error - try user repo creation instead
      if (err.status === 404 || err.status === 403) {
        return this.createUserRepo(options);
      }
      
      return { success: false, error: errorMessage };
    }
  }

  /**
   * Create repository under user account (fallback if org creation fails)
   */
  private async createUserRepo(options: CreateRepoOptions): Promise<CreateGitHubRepoResult> {
    try {
      const octokit = this.getOctokit();
      const repoName = this.buildRepoName(options.serviceName);

      this.logger.info({ repoName }, 'Falling back to user repository creation');

      const response = await octokit.repos.createForAuthenticatedUser({
        name: repoName,
        description: options.description ?? `Generated by ChronosOps for ${options.serviceName}`,
        private: options.isPrivate ?? true,
        auto_init: options.initializeWithReadme ?? false,
        has_issues: false,
        has_wiki: false,
        has_projects: false,
      });

      const repo = this.mapToRepoInfo(response.data);
      this.logger.info({ repoName, repoId: repo.id }, 'User GitHub repository created');

      return { success: true, repo };
    } catch (error: unknown) {
      const err = error as { message?: string };
      const errorMessage = err.message ?? 'Unknown error creating user repository';
      this.logger.error({ error: errorMessage }, 'Failed to create user GitHub repository');
      return { success: false, error: errorMessage };
    }
  }

  /**
   * Get repository info
   */
  async getRepo(repoName: string): Promise<GitHubRepoInfo> {
    const octokit = this.getOctokit();
    const owner = this.getOwner();

    const response = await octokit.repos.get({
      owner,
      repo: repoName,
    });

    return this.mapToRepoInfo(response.data);
  }

  /**
   * Delete a repository
   */
  async deleteRepo(repoName: string): Promise<DeleteGitHubRepoResult> {
    try {
      const octokit = this.getOctokit();
      const owner = this.getOwner();

      this.logger.info({ owner, repoName }, 'Deleting GitHub repository');

      // Check if repo exists first
      const exists = await this.repoExists(repoName);
      if (!exists) {
        this.logger.info({ owner, repoName }, 'Repository does not exist, nothing to delete');
        return { success: true };
      }

      await octokit.repos.delete({
        owner,
        repo: repoName,
      });

      this.logger.info({ owner, repoName }, 'GitHub repository deleted');
      return { success: true };
    } catch (error: unknown) {
      const err = error as { message?: string };
      const errorMessage = err.message ?? 'Unknown error deleting repository';
      this.logger.error({ error: errorMessage, repoName }, 'Failed to delete GitHub repository');
      return { success: false, error: errorMessage };
    }
  }

  /**
   * List repositories for the organization/user
   */
  async listRepos(options?: { perPage?: number; page?: number }): Promise<GitHubRepoInfo[]> {
    const octokit = this.getOctokit();
    const owner = this.getOwner();

    const response = await octokit.repos.listForOrg({
      org: owner,
      type: 'all',
      per_page: options?.perPage ?? 30,
      page: options?.page ?? 1,
    });

    return response.data.map((repo) => this.mapToRepoInfo(repo));
  }

  /**
   * Get the authenticated user
   */
  async getAuthenticatedUser(): Promise<{ login: string; name: string | null }> {
    const octokit = this.getOctokit();
    const response = await octokit.users.getAuthenticated();
    return {
      login: response.data.login,
      name: response.data.name,
    };
  }

  /**
   * Verify GitHub credentials are valid
   */
  async verifyCredentials(): Promise<{ valid: boolean; user?: string; error?: string }> {
    try {
      const user = await this.getAuthenticatedUser();
      this.logger.info({ user: user.login }, 'GitHub credentials verified');
      return { valid: true, user: user.login };
    } catch (error: unknown) {
      const err = error as { message?: string };
      const errorMessage = err.message ?? 'Invalid GitHub credentials';
      return { valid: false, error: errorMessage };
    }
  }

  /**
   * Get clone URL for a repository
   */
  getCloneUrl(repoName: string, useSSH: boolean = false): string {
    const owner = this.getOwner();
    if (useSSH) {
      return `git@github.com:${owner}/${repoName}.git`;
    }
    return `https://github.com/${owner}/${repoName}.git`;
  }

  /**
   * Get authenticated clone URL (includes token for HTTPS)
   */
  getAuthenticatedCloneUrl(repoName: string): string {
    const owner = this.getOwner();
    const token = this.config.githubToken;
    return `https://${token}@github.com/${owner}/${repoName}.git`;
  }

  /**
   * Map Octokit response to our repo info type
   */
  private mapToRepoInfo(data: {
    id: number;
    name: string;
    full_name: string;
    description?: string | null;
    private: boolean;
    html_url: string;
    clone_url?: string;
    ssh_url?: string;
    default_branch?: string;
    created_at?: string | null;
    updated_at?: string | null;
    pushed_at?: string | null;
  }): GitHubRepoInfo {
    return {
      id: data.id,
      name: data.name,
      fullName: data.full_name,
      description: data.description ?? null,
      private: data.private,
      htmlUrl: data.html_url,
      cloneUrl: data.clone_url ?? '',
      sshUrl: data.ssh_url ?? '',
      defaultBranch: data.default_branch ?? 'main',
      createdAt: new Date(data.created_at ?? Date.now()),
      updatedAt: new Date(data.updated_at ?? Date.now()),
      pushedAt: data.pushed_at ? new Date(data.pushed_at) : null,
    };
  }
}
